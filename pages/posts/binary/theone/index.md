---
title: 二进制逆向学习笔记 (1)
subTitle: 正在更新中
date: 2025-08-27
updated: 2025-08-27
cover: /cover/binary/cover.jpg
toc: true
categories:
  - 学习笔记
  - 二进制逆向
tags:
  - 二进制
  - 逆向工程
---

> 2025 年 8 月 27 日，为了参加即将举办的网安攻防大赛，开始恶补二进制逆向相关的知识

# 先正向，再逆向

对于任何逆向分析，首先应该掌握其**正向流程**，这对逆向很有帮助

本文分为五部分介绍入门二进制逆向需要的基础知识、学习路径

---

## 🧮 编程语言

> 对于程序开发通常分为 `Windows`，`Linux/Android`，`IOS/Mac` 三个平台，有些编程语言是位特定平台服务的(如 **VB**、**Kotlin**)，有些语言是跨平台的

为了更好的接触底层，我们需要剔除掉非跨平台的脚本语言 (如 **shell**、**python**、**php** 等)

### 三大操作系统的主要编程语言

| 操作系统          | 主要语言                    |
| ----------------- | --------------------------- |
| `Windows`         | **C C++**                   |
| `Linux` `Android` | **C C++ Java Kotlin**       |
| `IOS` `Mac`       | **C C++ Objective-C Swift** |

可以看到 `C` 是操作系统开发中的绝对核心语言，`C++` 在驱动和部分用户态框架中大量使用，其他语言主要是应用层

---

## 🖥️ 操作系统 API

> `API` (应用程序编程接口) 是操作系统提供的功能，你只需要调用它就能实现一些功能

`C` `C++` 写出来的程序，本质上只是 **“写出一堆 CPU 指令”**，而真正的 **“文件、网络、进程管理”** 这些能力，都是操作系统提供的

可以理解为 **编程语言 -> 操作系统 API -> 操作系统内核 -> 物理硬件** 的调度关系

#### 学习 `API` 开发在逆向时非常关键，因为：

看到一个 `API` 调用 (比如 `CreateFileA` ) ，你就能推测程序想干嘛

把 `汇编` 和 `API` 名字一一对应，逻辑就会清晰很多

---

## 📄 文件结构

> 当你写完一个程序，编译器并不是直接把机器指令丢到硬盘里，而是会 **打包成一个有组织的文件格式**

- **文件头 (Header)**

  用于记录这个文件的操作系统，架构，入口点地址，段表等信息

- **段/节区 (Sections / Segments)**

  存放不同类型的数据，比如代码段、数据段、符号表、调试信息

- **元数据**

  动态链接库依赖、运行时信息、签名、校验码等

### 常见文件结构

| 格式       | 平台                              | 文件头                                                          | 主要编程语言                             |
| ---------- | --------------------------------- | --------------------------------------------------------------- | ---------------------------------------- |
| **PE**     | Windows                           | `4D 5A` (MZ) 后跟 PE\0\0 `50 45 00 00`                          | `C` `C++` `C#` `VB` `Delphi` `Rust` `Go` |
| **ELF**    | Linux Android                     | `7F 45 4C 46`                                                   | `C` `C++` `Rust` `Go`                    |
| **Mach-O** | Apple                             | `FE ED FA CE`(32 位) `FE ED FA CF`(64 位) `CA FE BA BE`(Fat/UB) | `C` `C++` `Obj-C` `Swift` `Rust` `Go`    |
| **DEX**    | Android Runtime - ART & Dalvik VM | `64 65 78 0A 30 33 35 00(dex.035)`                              | `Java` `Kotlin`                          |
| **CLASS**  | JVM                               | `CA FE BA BE`                                                   | `Java` `Kotlin` `Scala`                  |

#### 额外说明：

> 在 `.exe` 和 `.dll` 文件的开头基本都能看到 `4D 5A`

> `45 4C 46` 就是 **ELF** 的 ASCII 码，`7F` 是 ASCII 的 DEL 字符

> **APK** 的本质是一个 ZIP，解压后你可能会找到 `classes.dex`，里面包含应用程序所有的 Java、Kotlin 字节码

**操作系统加载器(Loader)** 会先读 **文件头**，根据里面的字段来判断`格式、目标架构、程序入口点、依赖` 等信息

---

## 🔍 分析工具

> 在二进制逆向学习中，分析工具是很重要的武器，他们大致可以分为 `静态分析`，`动态分析`、`编辑工具` 三大部分

#### 静态分析

> 静态分析的作用是在不运行目标程序的情况下，直接查看二进制文件的内容，比如文件头、段表、汇编代码

- **文件头查看工具**

  **Linux** : `file` `readelf` `objdump`

  **Windows** : `PEview` `dumpbin`

  **通用** : 十六进制编辑器(`HxD` `010 Editor`)

  **用途** : 快速判断文件格式、架构、依赖库

- **反编译工具**

  **IDA Pro** ：行业标准，支持反汇编 + 伪 C 反编译。

  **Ghidra** ：NSA 开源，功能强大，免费替代 IDA。

  **用途** ：把二进制机器码翻译成汇编，甚至是接近 C 的伪代码，便于理解逻辑。

**静态分析**的特点是: 安全(不会执行恶意代码)，但可能被**壳、混淆**等保护机制干扰

#### 动态分析

> 动态分析是在运行目标程序的情况下，通过调试器或 Hook 工具观察二进制程序的实际行为

- **调试器**

  **Windows**：x64dbg, OllyDbg, WinDbg

  **Linux**：gdb (+ pwndbg/gef/peda 插件增强)

  **macOS/iOS**：lldb

  **Android**：gdbserver + lldb, JEB/Frida

  **用途**：单步执行程序、查看寄存器变化、追踪 API 调用、观察内存状态。

- **系统调用跟踪工具**

  **Linux**：strace（跟踪系统调用）、ltrace（跟踪库调用）

  **Windows**：API Monitor

- **Hook 工具**

  **Frida**：跨平台 Hook 框架，常用于移动应用逆向。

  **Objection**：基于 Frida 的手机应用安全工具。

**动态分析**的特点是: 直观(看到真是运行情况)，但需要小心目标程序的**反调试机制**

#### 编辑工具

> 编辑工具可以直接修改二进制文件，去掉校验逻辑，跳过验证、改写指令

- **Hex Editor**

  **HxD**, **010 Editor** → 可以直接改字节。

- **PE/ELF 编辑工具**

  **LordPE**（Windows PE 文件）

  **ELF Parser**（Linux ELF 文件）

- **反汇编器自带 Patch 功能**

  **IDA**, **Radare2** 都支持在汇编视图里直接修改指令并保存。

**编辑工具**的特点是: 能改变结果，是破解补丁、修改逻辑的常用手段

**二进制逆向的核心流程是:**

**静态分析**理解结构 -> **动态分析**验证猜想 -> **编辑工具**修改程序

---

## ⚙️ 芯片指令

> 每一个程序最终在计算机上运行时，都是由**芯片指令**来控制硬件的，而这些指令和芯片架构息息相关

#### 机器语言与汇编语言

**机器语言**

程序经过编译后生成的就是 CPU 能直接执行的二进制命令，每条指令控制 CPU 做特定操作，比如加法、跳转、读写内存

**汇编语言**

为了方便人类理解，把机器码用**助记符**表示

例如 x86 指令 `0xB8 0x01 0x00 0x00 0x00` 对应汇编 `mov eax, 1`

汇编语言和机器码一一对应，通过汇编器可以转回二进制

#### 芯片指令与架构

**CPU 架构** 决定了能执行那些指令集，架构不同 -> 指令不同 -> 汇编也不同

| 架构           | 常用指令集/汇编风格       | 说明                                                       |
| -------------- | ------------------------- | ---------------------------------------------------------- |
| `x86`/`x86-64` | **Intel** / **AT&T 汇编** | PC 和 Windows / Linux 常用，C 编译器默认生成指令           |
| `ARM`/`ARM64`  | **ARM 汇编** / **Thumb**  | 手机（Android / iOS）、嵌入式设备常用，RISC 架构，指令精简 |
| `MIPS`         | **MIPS 汇编**             | 嵌入式设备和路由器历史常用                                 |
| `PowerPC`      | **PowerPC 汇编**          | 老款 macOS / 游戏机（如 Wii）用                            |
| `RISC-V`       | **RISC-V 汇编**           | 新兴开源架构，指令简洁，学习和实验方便                     |

> 一个 x86 程序无法直接在 ARM CPU 上运行，逆向时必须知道目标程序运行的架构，才能正确理解汇编指令

#### 汇编语言在逆向中的作用

通过汇编可以看出循环、条件跳转、函数调用，从而识别程序逻辑

汇编指令会展示调用系统的API或库函数的实际过程

动态分析和修改程序的操作都在汇编层进行，例如跳过检查、修改寄存器值

---
