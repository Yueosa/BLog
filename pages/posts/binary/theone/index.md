---
title: 二进制逆向学习笔记 (1)
date: 2025-08-27
updated: 2025-10-06
cover: /cover/binary/cover_theone.jpg
toc: true
categories:
  - 学习
  - 二进制逆向
tags:
  - 二进制
  - 逆向工程
---

# 先正向，再逆向

对于任何逆向分析，首先应该掌握其**正向流程**，这对逆向很有帮助

本文分为五部分介绍入门二进制逆向需要的基础知识、学习路径

---

## 🧮 编程语言

> 对于程序开发通常分为 `Windows`，`Linux/Android`，`IOS/Mac` 三个平台，有些编程语言是位特定平台服务的(如 **VB**、**Kotlin**)，有些语言是跨平台的

为了更好的接触底层，我们需要剔除掉非跨平台的脚本语言 (如 **shell**、**python**、**php** 等)

### 三大操作系统的主要编程语言

| 操作系统          | 主要语言                    |
| ----------------- | --------------------------- |
| `Windows`         | **C C++**                   |
| `Linux` `Android` | **C C++ Java Kotlin**       |
| `IOS` `Mac`       | **C C++ Objective-C Swift** |

可以看到 `C` 是操作系统开发中的绝对核心语言，`C++` 在驱动和部分用户态框架中大量使用，其他语言主要是应用层

---

## 🖥️ 操作系统 API

> `API` (应用程序编程接口) 是操作系统提供的功能，你只需要调用它就能实现一些功能

`C` `C++` 写出来的程序，本质上只是 **“写出一堆 CPU 指令”**，而真正的 **“文件、网络、进程管理”** 这些能力，都是操作系统提供的

可以理解为 **编程语言 -> 操作系统 API -> 操作系统内核 -> 物理硬件** 的调度关系

#### 学习 `API` 开发在逆向时非常关键，因为：

看到一个 `API` 调用 (比如 `CreateFileA` ) ，你就能推测程序想干嘛

把 `汇编` 和 `API` 名字一一对应，逻辑就会清晰很多

---

## 📄 文件结构

> 当你写完一个程序，编译器并不是直接把机器指令丢到硬盘里，而是会 **打包成一个有组织的文件格式**

- **文件头 (Header)**

  用于记录这个文件的操作系统，架构，入口点地址，段表等信息

- **段/节区 (Sections / Segments)**

  存放不同类型的数据，比如代码段、数据段、符号表、调试信息

- **元数据**

  动态链接库依赖、运行时信息、签名、校验码等

### 常见文件结构

| 格式       | 平台                              | 文件头                                                          | 主要编程语言                             |
| ---------- | --------------------------------- | --------------------------------------------------------------- | ---------------------------------------- |
| **PE**     | Windows                           | `4D 5A` (MZ) 后跟 PE\0\0 `50 45 00 00`                          | `C` `C++` `C#` `VB` `Delphi` `Rust` `Go` |
| **ELF**    | Linux Android                     | `7F 45 4C 46`                                                   | `C` `C++` `Rust` `Go`                    |
| **Mach-O** | Apple                             | `FE ED FA CE`(32 位) `FE ED FA CF`(64 位) `CA FE BA BE`(Fat/UB) | `C` `C++` `Obj-C` `Swift` `Rust` `Go`    |
| **DEX**    | Android Runtime - ART & Dalvik VM | `64 65 78 0A 30 33 35 00(dex.035)`                              | `Java` `Kotlin`                          |
| **CLASS**  | JVM                               | `CA FE BA BE`                                                   | `Java` `Kotlin` `Scala`                  |

#### 额外说明：

> 在 `.exe` 和 `.dll` 文件的开头基本都能看到 `4D 5A`

> `45 4C 46` 就是 **ELF** 的 ASCII 码，`7F` 是 ASCII 的 DEL 字符

> **APK** 的本质是一个 ZIP，解压后你可能会找到 `classes.dex`，里面包含应用程序所有的 Java、Kotlin 字节码

**操作系统加载器(Loader)** 会先读 **文件头**，根据里面的字段来判断`格式、目标架构、程序入口点、依赖` 等信息

---

## 🔍 分析工具

> 在二进制逆向学习中，分析工具是很重要的武器，他们大致可以分为 `静态分析`，`动态分析`、`编辑工具` 三大部分

这里只介绍本人比较熟悉的 **Windows** 工具，**Linux** 等平台如果以后有接触的话会进行补充

#### 静态分析

> 静态分析的作用是在不运行目标程序的情况下，直接查看二进制文件的内容，比如文件头、段表、汇编代码

- **文件头查看工具**

  **PE-bear** : 针对 Windows PE 的轻量“first view”检查器，快速查看 PE 表头、节、导入/导出、资源等，抗畸形 PE，适合初步静态侦查。

  **用途** : 快速判断文件格式、架构、依赖库

- **反编译工具**

  **IDA Pro** ：经典商用反汇编/反编译平台，插件生态与处理器支持最强，适合对复杂/闭源目标做深度逆向（也带调试器）。

  **Ghidra** ：NSA 出品的免费开源 SRE 框架，集成反汇编、反编译、图形化交互与脚本扩展，适合做深入静态反汇编与批量分析。

  **用途** ：把二进制机器码翻译成汇编，甚至是接近 C 的伪代码，便于理解逻辑。

**静态分析**的特点是: 安全(不会执行恶意代码)，但可能被**壳、混淆**等保护机制干扰

#### 动态分析

> 动态分析是在运行目标程序的情况下，通过调试器或 Hook 工具观察二进制程序的实际行为

- **调试器**

  **x32dbg / x64dbg**: Windows 下流行的开源用户态调试器（分别对应 32/64 位），UI 友好、插件丰富，适合交互式单步/断点/内存观察与脚本化调试。

  **Cheat Engine**: 最初为游戏修改而生的内存扫描/注入/修改工具，能做进程内搜索、内存写入、硬件断点、以及简单的脚本化运行时改写，对调试与内存分析很实用。

  **用途**：单步执行程序、查看寄存器变化、追踪 API 调用、观察内存状态。

**动态分析**的特点是: 直观(看到真是运行情况)，但需要小心目标程序的**反调试机制**

#### 编辑工具

> 编辑工具可以直接修改二进制文件，去掉校验逻辑，跳过验证、改写指令

- **Hex Editor**

  **HxD**: 十六进制编辑器，提供二进制文件的精确查看和编辑功能，支持快速搜索指定字节序列、文件结构解析、模板处理等（二进制文件分析和字节模式查找利器）。

- **PE / ELF 编辑工具**

  **PE-bear**: 修改 PE/ELF 头、节（section）、导入表、重定位、资源、节对齐等结构化改动。

- **反汇编器自带 Patch 功能**

  **IDA / Ghidra**: 能在语义层面（函数/指令）做修改，便于与注释、流程图同步；能导出可复现的 patch 脚本（IDC/Python/Ghidra script）。

**编辑工具**的特点是: 能改变结果，是破解补丁、修改逻辑的常用手段

#### 辅助工具

> 辅助工具用于更方便的掌握全局情况，进行特殊操作

- **工具**

  **OpenArk**: 开源的 anti-rootkit / 系统信息发现工具，帮助发现隐藏模块或可疑内核/驱动行为（用于宿主系统清查与取证辅助）。

  **Everything**: 超快的 Windows 文件名索引/搜索工具，便于在样本仓库里瞬间定位样本/符号等（文件管理/检索神器）。

  **RunAsTI64**: 用于以 TrustedInstaller（或更高权权）身份启动进程的工具（用于需要最高权限操作系统资源时的“临时权限提升”）。

  **Wireshark**: 开源的网络协议分析工具，用于捕获和分析网络流量，帮助分析恶意样本的网络通信行为、检测 C&C 服务器通信、数据泄露等网络活动（网络行为分析必备）。

**二进制逆向的核心流程是:**

**静态分析**理解结构 -> **动态分析**验证猜想 -> **编辑工具**修改程序

---

## ⚙️ 芯片指令

> 每一个程序最终在计算机上运行时，都是由**芯片指令**来控制硬件的，而这些指令和芯片架构息息相关

#### 机器语言与汇编语言

**机器语言**

程序经过编译后生成的就是 CPU 能直接执行的二进制命令，每条指令控制 CPU 做特定操作，比如加法、跳转、读写内存

**汇编语言**

为了方便人类理解，把机器码用**助记符**表示

例如 x86 指令 `0xB8 0x01 0x00 0x00 0x00` 对应汇编 `mov eax, 1`

汇编语言和机器码一一对应，通过汇编器可以转回二进制

#### 芯片指令与架构

**CPU 架构** 决定了能执行那些指令集，架构不同 -> 指令不同 -> 汇编也不同

| 架构                  | 常用指令集/汇编风格       | 说明                                                       |
| --------------------- | ------------------------- | ---------------------------------------------------------- |
| `x86`/`x86-64(AMD64)` | **Intel** / **AT&T 汇编** | PC 和 Windows / Linux 常用，C 编译器默认生成指令           |
| `ARM`/`ARM64`         | **ARM 汇编** / **Thumb**  | 手机（Android / iOS）、嵌入式设备常用，RISC 架构，指令精简 |
| `MIPS`                | **MIPS 汇编**             | 嵌入式设备和路由器历史常用                                 |
| `PowerPC`             | **PowerPC 汇编**          | 老款 macOS / 游戏机（如 Wii）用                            |
| `RISC-V`              | **RISC-V 汇编**           | 新兴开源架构，指令简洁，学习和实验方便                     |

> 一个 x86 程序无法直接在 ARM CPU 上运行，逆向时必须知道目标程序运行的架构，才能正确理解汇编指令

#### 汇编语言在逆向中的作用

通过汇编可以看出循环、条件跳转、函数调用，从而识别程序逻辑

汇编指令会展示调用系统的 API 或库函数的实际过程

动态分析和修改程序的操作都在汇编层进行，例如跳过检查、修改寄存器值

---
